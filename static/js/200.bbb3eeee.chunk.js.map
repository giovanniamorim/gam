{"version":3,"file":"static/js/200.bbb3eeee.chunk.js","mappings":"2OAKA,MA2EA,EA3EkC,KAE9B,SAAC,KAAD,WACE,UAAC,KAAD,CAAMA,GAAI,GAAV,WACE,UAAC,KAAD,CAAOC,UAAU,OAAjB,WACE,SAAC,KAAD,WACE,4BAAQ,WAEV,SAAC,KAAD,WACA,gCACM,wBAAI,oBACJ,uBAAG,4QAEnB,wBAAI,4CACJ,2BACE,2BAAI,4BAAQ,cAAkB,qFAC9B,2BAAI,4BAAQ,0BACV,2BACE,wBAAI,kKACJ,wBAAI,4PACJ,wBAAI,+VAIR,iBAAKA,UAAU,WAAf,UAA0B,KAAC,4BAAQ,wBAAyB,mjBAI9D,wBAAI,6BACJ,2BACE,2BAAI,4BAAQ,cAAkB,8HAC9B,2BAAI,4BAAQ,0BACV,2BACE,wBAAI,2aACJ,wBAAI,sQACJ,wBAAI,yMAIV,iBAAKA,UAAU,WAAf,UAA0B,KAAC,4BAAQ,wBAAyB,mwBAE5D,wBAAI,8BACJ,2BACE,2BAAI,4BAAQ,cAAkB,mHAC9B,2BAAI,4BAAQ,0BACV,2BACE,wBAAI,0KACJ,wBAAI,0IACJ,wBAAI,iLACJ,wBAAI,4OACJ,wBAAI,mKAIV,iBAAKA,UAAU,WAAf,UAA0B,KAAC,4BAAQ,wBAAyB,skBAMpD,SAAC,KAAD,WACM,SAAC,KAAD,WACA,iBAAKA,UAAU,gDAAf,WACQ,SAAC,KAAD,CAASC,MAAM,UAAUD,UAAU,UAAnC,SAA6C,YAG7C,SAAC,KAAD,CAASC,MAAM,UAAf,SAAyB,0B","sources":["views/gam/expansao/ExpansaoEscalabilidadeGam.js"],"sourcesContent":["import { CCard, CCardBody, CCardHeader, CCol, CRow, CButton } from '@coreui/react';\nimport React from 'react';\n\nimport '../../../scss/_custom.scss';\n\nconst ExpansaoEscalabilidadeGam = () => {\n  return (\n    <CRow>\n      <CCol xs={12}>\n        <CCard className=\"mb-4\">\n          <CCardHeader>\n            <strong>GAM</strong>\n          </CCardHeader>\n          <CCardBody>\n          <section>\n                <h3>Escalabilidade</h3>\n                <p>Esta etapa visa capacitar a aplicação a crescer de maneira eficiente e adaptar-se às demandas variáveis do ambiente. As principais áreas de foco são a adição de novos micro-frontends, o gerenciamento de carga e as estratégias de cache.</p>\n\n<h3>Adição de Novos Micro-Frontends:</h3>\n<ul>\n  <li><strong>Objetivo:</strong> Facilitar a incorporação de novos micro-frontends ao sistema existente.</li>\n  <li><strong>Recomendações:</strong>\n    <ul>\n      <li>Modularização Dinâmica: Desenvolver arquitetura modular que suporte a adição dinâmica de novos micro-frontends sem impactar os existentes.</li>\n      <li>Balanceamento de Carga: Implementar sistema de balanceamento de carga automático como serviços de orquestração, usando ferramentas como Kubernetes, para facilitar o dimensionamento automático com base nas métricas de tráfego.</li>\n      <li>Gestão de Cache: Adote estratégias de cache, como Redis, para armazenar temporariamente as respostas de micro-serviços, melhorando o throughput da composição de micro-frontends. Explore o armazenamento de DOM de micro-frontends em caches in-memory para reduzir a necessidade de recomposição a cada requisição.</li>\n    </ul>\n  </li>\n</ul>\n  <div className=\"blue-box\"> <strong>Exemplo Prático:</strong> \n  Em um cenário de comércio eletrônico baseado em micro-frontends, um novo micro-frontend chamado \n  &quot;Recomendações Personalizadas&quot; foi adicionado. Implementa-se um sistema de balanceamento de carga automático com Kubernetes para escalabilidade dinâmica com base no tráfego. Para aprimorar o desempenho, utiliza-se estratégias de cache, incluindo Redis, para armazenar temporariamente respostas de micro-serviços e o DOM de micro-frontends em caches in-memory, reduzindo a necessidade de recomposição a cada requisição.</div>\n\n<h3>Gerenciamento de Carga:</h3>\n<ul>\n  <li><strong>Objetivo:</strong> Garantir a eficiência operacional e o desempenho otimizado da aplicação, mesmo diante de demandas crescentes.</li>\n  <li><strong>Recomendações:</strong>\n    <ul>\n      <li>Autoescalabilidade na Nuvem: Utilize funcionalidades de autoescalabilidade oferecidas por provedores de nuvem para ajustar dinamicamente a infraestrutura com base nos padrões de tráfego. Escolha camadas de computação eficientes, como contêineres, para rápida execução, e considere opções gerenciadas, como serviços serverless, para simplificar a operacionalização da infraestrutura.</li>\n      <li>Previsão de Carga e Ajuste Manual: Estabelecer uma infraestrutura de linha de base capaz de lidar com cargas previsíveis, como vendas da Black Friday, adotando práticas de comparação entre diferentes serviços e opções plug-and-play.</li>\n      <li>Otimização de Latência com CDN: Utilizar uma CDN para aumentar a velocidade de entrega das páginas da web, reduzindo a latência entre o cliente e o conteúdo solicitado.</li>\n    </ul>\n  </li>\n</ul>\n<div className=\"blue-box\"> <strong>Exemplo Prático:</strong> Para otimizar o desempenho da plataforma de comércio eletrônico, foi aproveitada a autoescalabilidade na nuvem, utilizando serviços serverless e contêineres para ajustar dinamicamente a infraestrutura com base em padrões de tráfego, garantindo rápida execução e eficiência operacional. Para lidar com picos previsíveis, como as vendas da &quot;Black Friday&quot;, estabeleceu-se uma infraestrutura de linha de base com ajustes manuais quando necessário, utilizando práticas de comparação entre diferentes serviços e opções plug-and-play. Além disso, incorporou-se uma CDN para otimizar a latência, acelerando a entrega de páginas web e aprimorando a experiência do usuário em cenários de alta demanda.</div>\n\n<h3>Estratégias de Cache:</h3>\n<ul>\n  <li><strong>Objetivo:</strong> Otimizar o desempenho da aplicação reduzindo a carga nos servidores e acelerando o tempo de resposta.</li>\n  <li><strong>Recomendações:</strong>\n    <ul>\n      <li>Cache de Conteúdo Estático: Implementar cache para conteúdo estático, como imagens, folhas de estilo e scripts, reduzindo a latência de carregamento.</li>\n      <li>Cache de Dados Dinâmicos: Utilizar estratégias de cache para dados dinâmicos, minimizando consultas frequentes ao servidor.</li>\n      <li>Invalidação de Cache Eficiente: Implementar métodos eficazes de invalidação de cache para garantir que os usuários recebam informações atualizadas.</li>\n      <li>Cache de Respostas: Implementar caches para armazenar temporariamente as respostas de micro-frontends, utilizando soluções como Redis, armazenando temporariamente as respostas de micro-serviços para aumentar o throughput.</li>\n      <li>Armazenamento de DOM em Cache: Armazenar o DOM completo de micro-frontends em caches in-memory para evitar composição a cada requisição.</li>\n    </ul>\n  </li>\n</ul>\n<div className=\"blue-box\"> <strong>Exemplo Prático:</strong> Em uma aplicação web, introduziu-se caches para conteúdo estático (imagens e estilos), dados dinâmicos e respostas de micro-frontends e micro-serviços, utilizando soluções como Redis. Essas abordagens reduzem a latência de carregamento, minimizam consultas frequentes aos servidores e aumentam o throughput. Além disso, adotou-se métodos de invalidação de cache para garantir informações atualizadas e armazenou-se o DOM de micro-frontends em caches in-memory, evitando composição excessiva a cada requisição.</div>\n\n                \n            </section>\n          </CCardBody>\n        </CCard>\n        <CCard>\n              <CCardBody>\n              <div className=\"d-grid gap-2 d-md-flex justify-content-md-end\">\n                      <CButton color=\"primary\" className=\"me-md-2\">\n                        Voltar\n                      </CButton>\n                      <CButton color=\"primary\">Avançar</CButton>\n              </div>\n              </CCardBody>\n              </CCard>\n      </CCol>\n    </CRow>\n  )\n}\n\nexport default ExpansaoEscalabilidadeGam\n"],"names":["xs","className","color"],"sourceRoot":""}